<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<h2 class="title-end">WebDAV</h2>
<div class="title-end-content">
    依赖：
    <pre>
                    <code class="language-xml">
                        &lt;dependency&gt;
                            &lt;groupId&gt;org.apache.jackrabbit&lt;/groupId&gt;
                            &lt;artifactId&gt;jackrabbit-standalone&lt;/artifactId&gt;
                            &lt;version&gt;1.6.5&lt;/version&gt;
                        &lt;/dependency&gt;
                    </code>
                </pre>
    <hr>
    我封装的WebDAVUtil：
    <pre>
                            <code class="language-java">
                                import lombok.Data;
                                import org.apache.commons.httpclient.Credentials;
                                import org.apache.commons.httpclient.HttpClient;
                                import org.apache.commons.httpclient.UsernamePasswordCredentials;
                                import org.apache.commons.httpclient.auth.AuthScope;
                                import org.apache.commons.httpclient.methods.GetMethod;
                                import org.apache.commons.httpclient.methods.InputStreamRequestEntity;
                                import org.apache.commons.httpclient.methods.RequestEntity;
                                import org.apache.jackrabbit.webdav.client.methods.DeleteMethod;
                                import org.apache.jackrabbit.webdav.client.methods.MkColMethod;
                                import org.apache.jackrabbit.webdav.client.methods.PutMethod;

                                import java.io.File;
                                import java.io.FileInputStream;
                                import java.io.FileOutputStream;
                                import java.io.IOException;
                                import java.net.URLEncoder;
                                import java.util.Scanner;
                                import java.util.UUID;

                                @Data
                                public class WebDAVUtil {

                                    private String url;

                                    private HttpClient client;

                                    /**
                                     * 构造方法，创建对象后，可以调用其中的方法
                                     *
                                     * @param url      WebDAV的目录，坚果云是 https://dav.jianguoyun.com/dav/
                                     * @param username 用户名
                                     * @param password 密码
                                     */
                                    public WebDAVUtil(String url, String username, String password) {
                                        this.url = url;
                                        this.client = new HttpClient();
                                        Credentials creds = new UsernamePasswordCredentials(username, password);
                                        client.getState().setCredentials(AuthScope.ANY, creds);
                                        client.getParams().setAuthenticationPreemptive(true);
                                    }

                                    /**
                                     * 测试密码登录信息是否正确
                                     * @return true正确 false错误
                                     */
                                    public boolean test() {
                                        GetMethod method = new GetMethod(url);
                                        try {
                                            client.executeMethod(method);
                                        } catch (IOException e) {
                                            e.printStackTrace();
                                        }

                                        return method.getStatusCode() != 401;
                                    }

                                    /**
                                     * 创建目录
                                     *
                                     * @param path 目录路径，可以为多级目录，前后不需要斜杠
                                     */
                                    public void mkdir(String path) {
                                        try {
                                            // 新建文件夹
                                            String dirUrl = url + URLEncoder.encode(path, "utf-8");
                                            MkColMethod mkDir = new MkColMethod(dirUrl);
                                            this.client.executeMethod(mkDir);

                                            int statusCode = mkDir.getStatusCode();
                                            String statusText = mkDir.getStatusText();
                                            if (statusCode != 201) {
                                                throw new RuntimeException(statusText);
                                            }
                                        } catch (IOException e) {
                                            e.printStackTrace();
                                        }
                                    }

                                    /**
                                     * 删除目录或文件
                                     *
                                     * @param path 删除的目录或文件所在的目录
                                     * @param name 删除的目录或文件
                                     *             注意：文件与文件夹是不可能同名的，所以一个名称可以唯一确定一个目录或文件夹
                                     */
                                    public void delete(String path, String name) {
                                        try {
                                            String fileUrl = url + URLEncoder.encode(path + "/" + name, "utf-8");
                                            DeleteMethod davDelete = new DeleteMethod(fileUrl);
                                            client.executeMethod(davDelete);

                                            int statusCode = davDelete.getStatusCode();
                                            String statusText = davDelete.getStatusText();
                                //            if (statusCode != 201) {
                                                // statusCode = 404， statusText = Not Found 是要删除的文件或文件夹不存在
                                //                throw new RuntimeException(statusText);
                                //            }
                                        } catch (IOException e) {
                                            e.printStackTrace();
                                        }
                                    }

                                    /**
                                     * 上传文件
                                     *
                                     * @param file     上传的文件
                                     * @param path     上传的文件要保存的目录
                                     * @param fileName 上传的文件要保存的文件名，通常可用源文件名
                                     *                 调用可参考 webDAVUtil.upload(new File("C:\\Users\\DELL\\Desktop\\0XYX[`J{8E7MT7%`SY97FNE.png"), "test", "test.png");
                                     */
                                    public void upload(File file, String path, String fileName) {
                                        try {

                                            String uplaodFileUrl = url + URLEncoder.encode(path + "/" + fileName, "utf-8");
                                            PutMethod put = new PutMethod(uplaodFileUrl);
                                            FileInputStream fileInputStream = new FileInputStream(file);
                                            RequestEntity requestEntity = new InputStreamRequestEntity(fileInputStream);
                                            put.setRequestEntity(requestEntity);
                                            client.executeMethod(put);

                                            int statusCode = put.getStatusCode();
                                            String statusText = put.getStatusText();
                                            if (statusCode != 201 && statusCode != 204) {
                                                throw new RuntimeException(statusText);
                                            }
                                            fileInputStream.close();
                                        } catch (Exception e) {
                                            e.printStackTrace();
                                        }
                                    }

                                    /**
                                     * 下载文件
                                     *
                                     * @param path     要下载的文件的路径
                                     * @param fileName 文件名称
                                     * @param saveDir  要保存的目录
                                     */
                                    public void download(String path, String fileName, String saveDir) {
                                        try {
                                            // 下载文件
                                            String fileUrl = url + URLEncoder.encode(path + "/" + fileName, "utf-8");
                                            GetMethod method = new GetMethod(fileUrl);
                                            client.executeMethod(method);

                                            int statusCode = method.getStatusCode();
                                            String statusText = method.getStatusText();
                                            if (statusCode != 201 && statusCode != 200) {
                                                throw new RuntimeException(statusText);
                                            }

                                            // 保存文件到磁盘
                                            String fileDir = saveDir;
                                            File fileDirObj = new File(fileDir);
                                            if (!fileDirObj.exists()) {
                                                fileDirObj.mkdirs();
                                            }

                                            File fileObj = new File(fileDirObj, fileName);
                                            FileOutputStream fops = new FileOutputStream(fileObj);
                                            fops.write(method.getResponseBody());
                                            fops.close();
                                        } catch (Exception e) {
                                            e.printStackTrace();
                                        }
                                    }

                                    /**
                                     * 获取文件（不下载）
                                     * @param path 文件路径
                                     * @param fileName 文件名
                                     * @return 字符串
                                     */
                                    public String get(String path, String fileName) throws Exception {
                                        String fileUrl = url + URLEncoder.encode(path + "/" + fileName, "utf-8");
                                        GetMethod method = new GetMethod(fileUrl);
                                        client.executeMethod(method);

                                        int statusCode = method.getStatusCode();
                                        String statusText = method.getStatusText();
                                        if (statusCode != 201 && statusCode != 200) {
                                            throw new RuntimeException(statusText);
                                        }

                                        // 保存文件到磁盘（临时）
                                        String fileDir = UUID.randomUUID().toString();

                                        File file = new File(fileDir);
                                        FileOutputStream fops = new FileOutputStream(file);
                                        fops.write(method.getResponseBody());
                                        fops.close();

                                        StringBuffer stringBuffer = new StringBuffer();
                                        FileInputStream in = new FileInputStream(fileDir);
                                        Scanner sc = new Scanner(in, "GBK");
                                        while (sc.hasNextLine()) {
                                            stringBuffer.append(sc.nextLine());
                                        }
                                        sc.close();
                                        file.delete();
                                        return stringBuffer.toString();
                                    }
                                }
                            </code>
                        </pre>
</div><!-- WebDAV -->

<h2 class="title-end">AES</h2>
<div class="title-end-content">
                        <pre>
                <code class="language-java">
                    import java.security.Key;
                    import javax.crypto.Cipher;

                    // 参考：https://www.jianshu.com/p/6dad4671f26a

                    /**
                     * 使用DES算法对字符串进行加密解密 (加密解密的操作步骤正好相反, 参考 {@link #encrypt(String)}, {@link #decrypt(String)})
                     */
                    public class AES {
                        private static String defaultSecretKey = "default_secret_key"; //默认密钥
                        private Cipher encryptCipher = null; //加密器
                        private Cipher decryptCipher = null; //解密器

                        /**
                         * @param secretKey 加密解密使用的密钥
                         */
                        public AES(String secretKey) {
                            Key key;
                            try {
                                key = getKey(secretKey.getBytes());
                                encryptCipher = Cipher.getInstance("DES");
                                encryptCipher.init(Cipher.ENCRYPT_MODE, key);
                                decryptCipher = Cipher.getInstance("DES");
                                decryptCipher.init(Cipher.DECRYPT_MODE, key);
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }

                        /**
                         * 加密 (逻辑: 1. 将要加密的字符串转换为字节数组(byte array)<br/>
                         *            2. 将第一步的字节数组作为输入使用加密器(Cipher)的doFinal方法进行加密, 返回字节数组<br/>
                         *            3. 把加密后的字节数组转换成十六进制的字符串)<br/>
                         * @param strIn 要加密的字符串
                         * @return 返回加密后的十六进制字符串
                         * @throws Exception
                         */
                        public String encrypt(String strIn) throws Exception {
                            return byteArr2HexStr(encrypt(strIn.getBytes()));
                        }

                        private byte[] encrypt(byte[] arrB) throws Exception {
                            return encryptCipher.doFinal(arrB);
                        }

                        /**
                         * 解密 (逻辑: 1. 把加密后的十六进制字符串转换成字节数组(byte array)<br/>
                         *            2. 将第一步的字节数组作为输入使用加密器(Cipher)的doFinal方法进行解密, 返回字节数组(byte array)<br/>
                         *            3. 把解密后的字节数组转换成字符串)<br/>
                         * @param strIn
                         * @return
                         * @throws Exception
                         */
                        public String decrypt(String strIn) {
                            try {
                                return new String(decrypt(hexStr2ByteArr(strIn)));
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                            return null;
                        }

                        private byte[] decrypt(byte[] arrB) throws Exception {
                            return decryptCipher.doFinal(arrB);
                        }

                        public static String byteArr2HexStr(byte[] arrB) throws Exception {
                            int iLen = arrB.length;
                            // 每个byte用两个字符才能表示，所以字符串的长度是数组长度的两倍
                            StringBuffer sb = new StringBuffer(iLen * 2);
                            for (int i = 0; i < iLen; i++) {
                                int intTmp = arrB[i];
                                // 把负数转换为正数
                                while (intTmp < 0) {
                                    intTmp = intTmp + 256;
                                }
                                // 小于0F的数需要在前面补0
                                if (intTmp < 16) {
                                    sb.append("0");
                                }
                                sb.append(Integer.toString(intTmp, 16));
                            }
                            return sb.toString();
                        }

                        private static byte[] hexStr2ByteArr(String strIn) throws Exception {
                            byte[] arrB = strIn.getBytes();
                            int iLen = arrB.length;
                            // 两个字符表示一个字节，所以字节数组长度是字符串长度除以2
                            byte[] arrOut = new byte[iLen / 2];
                            for (int i = 0; i < iLen; i = i + 2) {
                                String strTmp = new String(arrB, i, 2);
                                arrOut[i / 2] = (byte) Integer.parseInt(strTmp, 16);
                            }
                            return arrOut;
                        }

                        private Key getKey(byte[] arrBTmp) throws Exception {
                            // 创建一个空的8位字节数组（默认值为0）
                            byte[] arrB = new byte[8];
                            // 将原始字节数组转换为8位
                            for (int i = 0; i < arrBTmp.length && i < arrB.length; i++) {
                                arrB[i] = arrBTmp[i];
                            }
                            // 生成密钥
                            Key key = new javax.crypto.spec.SecretKeySpec(arrB, "DES");
                            return key;
                        }

                        /**
                         * 用法实例
                         */
                        public static void main(String[] args) {
                            try {
                                String test = "ha哈哈111";
                                //注意这里，自定义的加密的KEY要和解密的KEY一致，这就是钥匙，如果你上锁了，却忘了钥匙，那么是解密不了的
                                AES des = new AES("leemenz"); //自定义密钥
                                System.out.println("加密前的字符：" + test);
                                System.out.println("加密后的字符：" + des.encrypt(test));
                                System.out.println("解密后的字符：" + des.decrypt(des.encrypt(test)));
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                    }
                </code>
            </pre>
</div><!-- AES -->

<h2 class="title-end">aliyun OSS</h2>
<div class="title-end-content">
    依赖：
    <pre>
                            <code class="language-xml">
                                &lt;dependency&gt;
                                    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
                                    &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
                                    &lt;version&gt;3.8.0&lt;/version&gt;
                                &lt;/dependency&gt;
                            </code>
                        </pre>
    <hr>
    我封装的WebDAVUtil：
    <pre>
                            <code class="language-java">
                                import com.aliyun.oss.ClientException;
                                import com.aliyun.oss.OSS;
                                import com.aliyun.oss.OSSClientBuilder;
                                import com.aliyun.oss.OSSException;
                                import com.aliyun.oss.model.UploadFileRequest;
                                import java.io.File;

                                public class MyUploadUtil {

                                    /**
                                     *
                                     * @param filePath 要上传的文件路径，如果不存在，会上传一个空文件
                                     *                 该文件名也是保存在阿里云对象存储中的文件名，如果重复则覆盖
                                     * @return 外部访问/下载链接
                                     */
                                    public static String upload(String filePath) {
                                        String endpoint = "http://oss-cn-shanghai.aliyuncs.com";
                                        String accessKeyId = "*******************************";
                                        String accessKeySecret = "*******************************";
                                        String bucketName = "pic-wsg";
                                        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
                                        File file = new File(filePath);
                                        String fileName = file.getName();

                                        try {
                                            UploadFileRequest uploadFileRequest = new UploadFileRequest(bucketName, fileName);
                                            // The local file to upload---it must exist.
                                            uploadFileRequest.setUploadFile(filePath);
                                            // Sets the concurrent upload task number to 5.
                                            uploadFileRequest.setTaskNum(10);
                                            // Sets the part size to 1MB.
                                            uploadFileRequest.setPartSize(1024 * 1024 * 1);
                                            // Enables the checkpoint file. By default it's off.
                                            uploadFileRequest.setEnableCheckpoint(true);

                                            ossClient.uploadFile(uploadFileRequest);
                                //            UploadFileResult uploadResult = ossClient.uploadFile(uploadFileRequest);
                                //            CompleteMultipartUploadResult multipartUploadResult = uploadResult.getMultipartUploadResult();
                                //            System.out.println(multipartUploadResult.getETag());

                                        } catch (OSSException oe) {
                                            System.out.println("Caught an OSSException, which means your request made it to OSS, "
                                                    + "but was rejected with an error response for some reason.");
                                            System.out.println("Error Message: " + oe.getErrorMessage());
                                            System.out.println("Error Code:       " + oe.getErrorCode());
                                            System.out.println("Request ID:      " + oe.getRequestId());
                                            System.out.println("Host ID:           " + oe.getHostId());
                                        } catch (ClientException ce) {
                                            System.out.println("Caught an ClientException, which means the client encountered "
                                                    + "a serious internal problem while trying to communicate with OSS, "
                                                    + "such as not being able to access the network.");
                                            System.out.println("Error Message: " + ce.getMessage());
                                        } catch (Throwable e) {
                                            e.printStackTrace();
                                        } finally {
                                            ossClient.shutdown();
                                        }
                                        return "https://pic-wsg.oss-cn-shanghai.aliyuncs.com/" + fileName;
                                    }
                                }
                            </code>
                        </pre>
</div><!-- aliyun oss -->

<h2 class="title-end">ValidateCode</h2>
<div class="title-end-content">
    <button class="layui-btn layui-btn-sm">下载</button>
    <span>https://lib-wsg.oss-cn-shanghai.aliyuncs.com/ValidateCode.jar</span>
    <hr>
    用于生成验证码，参考代码：
    <pre>
                            <code class="language-java">
                                @RequestMapping("get_verification_code")
                                public void getVerificationCode(HttpSession session, HttpServletResponse response,
                                                            @RequestParam(defaultValue = "100") int width, @RequestParam(defaultValue = "30") int height,
                                                            @RequestParam(defaultValue = "4") int codeCount, @RequestParam(defaultValue = "6") int lineCount) throws IOException {
                                    ValidateCode validateCode = new ValidateCode(width, height, codeCount, lineCount);
                                    String code = validateCode.getCode().toLowerCase();
                                    System.out.println("验证码是：" + code);
                                    session.setAttribute(SessionKeyConst.VERIFICATION_CODE, code);
                                    validateCode.write(response.getOutputStream());
                                }
                            </code>
                        </pre>
</div><!-- ValidateCode -->

<h2 class="title-end">ResponseCode & ServerResponse</h2>
<div class="title-end-content">
                        <pre>
                <code class="language-java">
                    public class ResponseCodeConst {
                        public static final Integer SUCCESS = 0;
                        public static final Integer WRONG_PASSWORD = 101;

                        public static Map&lt;Integer, String&gt; responseMessage = new HashMap&lt;Integer, String&gt;() {{
                            put(WRONG_PASSWORD, "The password is wrong.");    // 密码错误

                        }};

                        public static String getResponseMessageByResponseCode(Integer responseCode) {
                            return responseMessage.get(responseCode);
                        }
                    }
                </code>
            </pre>
    <pre>
                            <code class="language-java">
                            @Getter
                            @JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)
                            public class ServerResponse&lt;T&gt; implements Serializable {
                                private int status;
                                private String msg;
                                private T data;

                                private ServerResponse(int status) {
                                    this.status = status;
                                }

                                private ServerResponse(int status, String msg) {
                                    this.status = status;
                                    this.msg = msg;
                                }

                                private ServerResponse(int status, T data) {
                                    this.status = status;
                                    this.data = data;
                                }

                                public static &lt;T&gt; ServerResponse&lt;T&gt; createSuccessResponse() {
                                    return new ServerResponse&lt;&gt;(ResponseCodeConst.SUCCESS);
                                }

                                public static &lt;T&gt; ServerResponse&lt;T&gt; createSuccessResponse(T data) {
                                    return new ServerResponse&lt;&gt;(ResponseCodeConst.SUCCESS, data);
                                }

                                public static &lt;T&gt; ServerResponse&lt;T&gt; createErrorResponse(Integer responseCode) {
                                    return new ServerResponse&lt;&gt;(responseCode, ResponseCodeConst.getResponseMessageByResponseCode(responseCode));
                                }

                                public boolean whetherSuccess() {
                                    return this.status == ResponseCodeConst.SUCCESS;
                                }
                            }
                        </code>
                        </pre>
</div><!-- ResponseCode & ServerResponse -->

<h2 class="title-end">MyBatis PageHelper</h2>
<div class="title-end-content">
                        <pre>
                <code class="language-java">
                    public PageInfo getAccountList(int pageNum, int pageSize) {
                        // 记录开始
                        PageHelper.startPage(pageNum, pageSize);
                        // 填充查询逻辑
                        List&lt;Account&gt; accounts = accountMapper.selectByExample(null);
                        // 收尾
                        PageInfo pageResult = new PageInfo(accounts);
                        pageResult.setList(accounts);
                        return pageResult;
                    }
                </code>
            </pre>
</div><!-- MyBatis PageHelper -->


<script src="layui/layui.js" charset="utf-8"></script>
<script src="jQuery/jquery-3.4.1.min.js"></script>
<script src="prism/prism.js"></script>
<script src="js/common.js"></script>
</body>
</html>